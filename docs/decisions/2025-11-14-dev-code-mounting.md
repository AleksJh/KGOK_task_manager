\# Документация: Решение проблемы монтирования кода в Docker без конфликта с Entrypoint



\*\*Дата:\*\* 14 ноября 2025 

\*\*Статус:\*\* Реализовано
\*\*Автор:\*\* Aleksan Jhangiryan   

\*\*Решённая проблема:\*\* Восстановление возможности горячей перезагрузки кода в development-режиме без нарушения работы entrypoint скрипта



---



\## Контекст и История Проблемы



\### Исходная Ситуация

До недавнего времени в проекте использовался bind mount для монтирования исходного кода в Docker-контейнер:

```yaml

volumes:

&nbsp; - ./:/app

```



Это позволяло видеть изменения кода мгновенно на `localhost` без пересборки контейнера — стандартный подход для комфортной разработки.



\### Возникшая Проблема

При монтировании `./:/app` возникла критическая проблема: \*\*Volume mount затенял entrypoint скрипт\*\*.



\*\*Механика проблемы:\*\*

\- Docker ENTRYPOINT был настроен на `/app/entrypoint.sh`

\- При bind mount `./:/app`, содержимое локального каталога \*\*полностью замещало\*\* содержимое `/app` в контейнере

\- Скрипт `entrypoint.sh`, который был скопирован в образ при сборке, становился недоступен

\- Контейнер не мог запуститься из-за отсутствия entrypoint



\### Временное Решение (До Сегодня)

Был сделан откат к копированию кода в образ через `COPY` в Dockerfile:

```dockerfile

COPY . /app

```



\*\*Последствия:\*\*

\- ✅ Entrypoint работает корректно

\- ❌ Каждое изменение кода требует полной пересборки контейнера (`docker compose build`)

\- ❌ Потеря скорости итераций в разработке

\- ❌ Ухудшение Developer Experience (DX)



---



\## Техническое Решение



\### Принцип: Изоляция Инфраструктуры от Кода Приложения



Корень проблемы — \*\*конфликт namespace\*\* между инфраструктурными файлами контейнера и монтируемым кодом приложения.



\*\*Золотое правило Docker-разработки:\*\*

> Никогда не монтируйте рабочий каталог поверх директории, содержащей инфраструктурные скрипты контейнера (ENTRYPOINT, CMD, конфигурационные файлы).



\### Выбранная Стратегия



Реализован \*\*паттерн разделения сред\*\* с изоляцией entrypoint:



1\. \*\*Перенос Entrypoint за пределы монтируемого пути\*\*

2\. \*\*Создание Development Override\*\* для bind mount

3\. \*\*Включение Hot Reload\*\* через Gunicorn



---



\## Реализованные Изменения



\### 1. Перенос Entrypoint в Системный Путь



\*\*Файл:\*\* `docker/web/Dockerfile`



\*\*Было:\*\*

```dockerfile

COPY docker/web/entrypoint.sh /app/entrypoint.sh

RUN chmod +x /app/entrypoint.sh

ENTRYPOINT \["/app/entrypoint.sh"]

```



\*\*Стало:\*\*

```dockerfile

COPY docker/web/entrypoint.sh /usr/local/bin/entrypoint.sh

RUN chmod +x /usr/local/bin/entrypoint.sh

ENTRYPOINT \["/usr/local/bin/entrypoint.sh"]

```



\*\*Обоснование:\*\*

\- `/usr/local/bin/` — стандартный системный путь для пользовательских исполняемых файлов в Linux

\- Этот путь \*\*никогда не монтируется\*\* для кода приложения

\- Entrypoint остаётся доступным независимо от bind mount на `/app`



\### 2. Development Override с Bind Mount



\*\*Файл:\*\* `docker-compose.override.yml` (создан)



```yaml

services:

&nbsp; web:

&nbsp;   volumes:

&nbsp;     - ./:/app

&nbsp;   command: gunicorn --bind 0.0.0.0:8000 --reload kapantask.wsgi:application

```



\*\*Назначение:\*\*

\- Docker Compose \*\*автоматически\*\* объединяет `docker-compose.yml` + `docker-compose.override.yml`

\- Монтирование кода: `./:/app` — изменения на хосте мгновенно доступны в контейнере

\- `--reload` флаг Gunicorn — автоматическая перезагрузка процесса при изменении `.py` файлов



\### 3. Базовая Конфигурация (Production-Like)



\*\*Файл:\*\* `docker-compose.yml` (без изменений в логике)



```yaml

services:

&nbsp; web:

&nbsp;   volumes:

&nbsp;     - static\_volume:/app/staticfiles

&nbsp;     - media\_volume:/app/media

&nbsp;   command: gunicorn --bind 0.0.0.0:8000 kapantask.wsgi:application

```



\*\*Характеристики:\*\*

\- Код копируется в образ при сборке (`COPY . /app` в Dockerfile)

\- Монтируются только персистентные тома (static, media)

\- Нет `--reload` — стабильная работа как в production



---



\## Использование



\### Development-режим (Hot Reload)



```bash

\# Запуск с автоматическим применением override

docker compose up -d



\# Что происходит:

\# 1. Compose объединяет docker-compose.yml + docker-compose.override.yml

\# 2. Код монтируется с хоста (./:/app)

\# 3. Gunicorn запускается с --reload

\# 4. Изменения в .py файлах → автоматическая перезагрузка

```



\### Production-режим (Stable)



```bash

\# Запуск без override (только базовая конфигурация)

docker compose -f docker-compose.yml up -d



\# Что происходит:

\# 1. Используется только docker-compose.yml

\# 2. Код берётся из образа (скопирован при сборке)

\# 3. Gunicorn без --reload

\# 4. Стабильная работа, как в production

```



---



\## Преимущества Решения



\### Developer Experience (DX)

\- ✅ \*\*Мгновенное применение изменений\*\* — не требуется пересборка контейнера

\- ✅ \*\*Автоматическая перезагрузка\*\* — Gunicorn отслеживает изменения файлов



\### Архитектурная Чистота

\- ✅ \*\*Разделение сред\*\* — явная граница между Dev и Prod конфигурациями

\- ✅ \*\*Принцип изоляции\*\* — инфраструктурные скрипты отделены от кода приложения

\- ✅ \*\*Отсутствие конфликтов\*\* — entrypoint всегда доступен



\### Безопасность и Надёжность

\- ✅ \*\*Production не затронут\*\* — базовая конфигурация осталась стабильной

\- ✅ \*\*Явное управление\*\* — dev-режим включается наличием override файла

\- ✅ \*\*Соответствие стандартам\*\* — использование `/usr/local/bin/` для скриптов



---



\### Почему `/usr/local/bin/`?



Согласно \[Filesystem Hierarchy Standard (FHS)](https://refspecs.linuxfoundation.org/FHS\_3.0/fhs/index.html):

\- `/usr/local/bin/` — для локальных исполняемых файлов, устанавливаемых администратором

\- Этот путь \*\*никогда не монтируется\*\* в типичных сценариях разработки

\- Стандартное местоположение для пользовательских скриптов в контейнерах



---





\## Уроки для Будущих Проектов



\### 1. Архитектурный Урок

> \*\*Разделяйте инфраструктуру и приложение\*\* — не только на уровне кода, но и на уровне файловой системы контейнера.



\### 2. DX Урок

> \*\*Оптимизация цикла обратной связи\*\* — каждая секунда, сэкономленная между изменением кода и его проверкой, умножается на сотни итераций в день.



\### 3. Инженерный Урок

> \*\*Задокументируйте "почему", а не только "что"\*\* — будущий вы (или ваш коллега) должен понимать контекст решения, чтобы не повторить ошибку.



---



\## Дополнительные Ресурсы



\### Документация

\- \[Docker Compose Override](https://docs.docker.com/compose/extends/)

\- \[Gunicorn Reload](https://docs.gunicorn.org/en/stable/settings.html#reload)

\- \[Filesystem Hierarchy Standard](https://refspecs.linuxfoundation.org/FHS\_3.0/fhs/index.html)



\### Связанные Файлы в Проекте

\- `docker/web/Dockerfile` — Определение образа с переносом entrypoint

\- `docker/web/entrypoint.sh` — Скрипт инициализации контейнера

\- `docker-compose.yml` — Базовая конфигурация (production-like)

\- `docker-compose.override.yml` — Development-конфигурация (hot reload)



---



\## Заключение



Реализованное решение демонстрирует \*\*баланс между удобством разработки и архитектурной чистотой\*\*. Вместо компромисса ("либо быстро, либо надёжно") достигнут синтез: разработка идёт быстро благодаря hot reload, а production-конфигурация остаётся стабильной и предсказуемой.



Ключевой инсайт — \*\*не бороться с ограничениями Docker, а работать с его паттернами\*\*: изоляция путей, разделение конфигураций, явное управление поведением.



Это решение \*\*масштабируемо\*\* (легко добавить другие сервисы), \*\*поддерживаемо\*\* (явные конфигурации), и \*\*обучаемо\*\* (документированные решения и альтернативы).



---



\*\*Автор:\*\* Aleksan Jhangiryan  

\*\*Дата документирования:\*\* 14 ноября 2025  

\*\*Статус:\*\* ✅ Реализовано и протестировано

